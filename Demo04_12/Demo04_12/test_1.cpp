#define _CRT_SECURE_NO_WARNINGS	1

#include <stdio.h>
//9.0
//1001.0 二进制
//(-1)^0 * 1.001 * 2^3
//(-s)^s *   M   * 2^E

//s - 0 符号位
//M - 1.001 有效位
//E - 3 指数位  
//指数位存入需加入中间值127  64位的加1023

//0.5
//0.1
//(-1)^0 * 1.0 * 2^-1

//32位浮点数 最高的1位是符号位s 接着的8位是指数E 剩下的23位为有效数字M
//M有效位基本都为1 所以存的时候舍去 取出的时候再补上 这样就可以保存24位有效数字

//int main()
//{
	//int n = 9;
	//float* pFloat = (float*)&n;
	//printf("n的值为:%d\n", n); //9
	//printf("*pFloat的值为:%f\n", *pFloat); //0.000000
	//(-1)^0 * 0.00000000000000000000000000001001 * 2^-126

	//*pFloat = 9.0;
	//1001.0
	//1.001*2^3
	//(-1)^0 * 1.001 * 2^3
	//0 1000001 000100000000000000000000 
	//如果按%d打印 第一位为符号位 为正数
	//printf("num的值为:%d\n", n); //1091567616
	//printf("*pFloat的值为:%f\n", *pFloat); //9.0
	//return 0;
//}

//E为全0
//浮点数的指数E等于1-127（1-1023）即为真实值 有效数字M不再加上第一位的1 而是还原为0.xxx 这样做是为了表示+—0，以及接近于0的很小的数字

//E为全1
//E+127=255 E=128
//1.xxx * 2^128 
//表示的正负无穷大的数字


int main()
{
	char arr1[] = "abcdef";
	char arr2[] = "abcdef";
	const char* p1 = "abcdef";
	const char* p2 = "abcdef";

	//if (arr1 == arr2) //地址不同
	//{
	//	printf("hehe\n");
	//}
	//else
	//{
	//	printf("haha\n");
	//}

	if (p1 == p2) //指向的地址相同
	{
		printf("hehe\n");
	}
	else
	{
		printf("haha\n");
	}
}